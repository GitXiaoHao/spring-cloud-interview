# 分布式事务
## CAP定理
- 解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导，首先就是CAP定理。
- 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：
  - Consistency（一致性）
  - Availability（可用性）
  - Partition tolerance （分区容错性）
- 它们的第一个字母分别是 C、A、P。Eric Brewer认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做 CAP 定理。
### 一致性
Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。
- 比如现在包含两个节点，其中的初始数据是一致的
- 当我们修改其中一个节点的数据时，两者的数据产生了差异
- 要想保住一致性，就必须实现node01 到 node02的数据 同步
### 可用性
- Availability （可用性）：用户访问分布式系统时，读或写操作总能成功。
- 只能读不能写，或者只能写不能读，或者两者都不能执行，就说明系统弱可用或不可用
### 分区容错
- Partition，就是分区，就是当分布式系统节点之间出现网络故障导致节点之间无法通信的情况
- node01和node02之间网关畅通，但是与node03之间网络断开。于是node03成为一个独立的网络分区；node01和node02在一个网络分区
- Tolerance，就是容错，即便是系统出现网络分区，整个系统也要持续对外提供服务
### 矛盾
- 在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（P）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（C）和可用性（A）了。
- 由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：
  - 允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP
  - 不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP
- 可见，在分布式系统中，A和C之间只能满足一个。
## BASE理论
既然分布式系统要遵循CAP定理，那么问题来了，我到底是该牺牲一致性还是可用性呢？如果牺牲了一致性，出现数据不一致该怎么处理？
人们在总结系统设计经验时，最终得到了一些心得：
- Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
- Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。
- Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。
- 以上就是BASE理论。
- 简单来说，BASE理论就是一种取舍的方案，不再追求完美，而是最终达成目标。因此解决分布式事务的思想也是这样，有两个方向：
  - AP思想：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如AT模式就是如此
  - CP思想：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如XA模式
## AT模式的脏写问题
- AT模式也分为两个阶段
  - 第一阶段是记录数据快照，执行并提交事务
  - 第二阶段根据阶段一的结果来判断
- 这种模式在大多数情况下（99%）并不会有什么问题，不过在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题
![at1.png](at1.png)
- 解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据
- 具体可以参考官方文档：https://seata.apache.org/zh-cn/docs/dev/mode/at-mode/
## TCC模式
TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：
-  try：资源的检测和预留；
-  confirm：完成资源操作业务；要求 try 成功 confirm 一定要能成功。
-  cancel：预留资源释放，可以理解为try的反向操作。 
### 流程分析
举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。
阶段一（ Try ）：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30
初始余额：
![tcc1.png](tcc1.png)
余额充足，可以冻结：
![tcc2.png](tcc2.png)
此时，总金额 = 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。


阶段二（Confirm)：假如要提交（Confirm），之前可用金额已经扣减，并转移到冻结金额。因此可用金额不变，直接冻结金额扣减30即可：
![tcc3.png](tcc3.png)
此时，总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元
阶段二(Canncel)：如果要回滚（Cancel），则释放之前冻结的金额，也就是冻结金额扣减30，可用余额增加30
![tcc4.png](tcc4.png)
### 事务悬挂和空回滚
- 假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞
![tcc5.png](tcc5.png)
- 如果阻塞时间太长，可能导致全局事务超时而触发二阶段的cancel操作。两个分支事务都会执行cancel操作
![tcc6.png](tcc6.png)
- 要知道，其中一个分支是未执行try操作的，直接执行了cancel操作，反而会导致数据错误。因此，这种情况下，尽管cancel方法要执行，但其中不能做任何回滚操作，这就是空回滚。
- 对于整个空回滚的分支事务，将来try方法阻塞结束依然会执行。但是整个全局事务其实已经结束了，因此永远不会再有confirm或cancel，也就是说这个事务执行了一半，处于悬挂状态，这就是业务悬挂问题。
### TCC的优点 {id="tcc_1"}
- 一阶段完成直接提交事务，释放数据库资源，性能好
- 相比AT模型，无需生成快照，无需使用全局锁，性能最强
- 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库
### TCC的缺点 {id="tcc_2"}
- 有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦
- 软状态，事务是最终一致
- 需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理
